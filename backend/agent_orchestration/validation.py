"""
Agent Workflow Validation System
Template Independent Graph Validation
"""

import logging
from typing import Dict, List, Tuple, Any

logger = logging.getLogger('agent_orchestration.validation')

class WorkflowGraphValidator:
    """Template-independent workflow graph validation"""
    
    # Supported agent types (from template capabilities)
    SUPPORTED_AGENT_TYPES = {
        'StartNode': {
            'required_fields': ['name', 'prompt'],
            'optional_fields': ['description'],
            'max_count': 1,
            'input_connections': 0,
            'output_connections': 1
        },
        'UserProxyAgent': {
            'required_fields': ['name'],
            'optional_fields': ['description', 'require_human_input'],
            'max_count': 5,
            'input_connections': 1,
            'output_connections': 1
        },
        'AssistantAgent': {
            'required_fields': ['name', 'system_message'],
            'optional_fields': ['description', 'llm_config'],
            'max_count': 10,
            'input_connections': 1,
            'output_connections': 1
        },
        'GroupChatManager': {
            'required_fields': ['name'],
            'optional_fields': ['description', 'speaker_selection'],
            'max_count': 2,
            'input_connections': 1,
            'output_connections': 1
        },
        'FunctionTool': {
            'required_fields': ['name', 'function_code'],
            'optional_fields': ['description', 'dependencies'],
            'max_count': 20,
            'input_connections': 0,
            'output_connections': 0
        }
    }\n    \n    @staticmethod\n    def validate_graph(graph_json: Dict, project_capabilities: Dict) -> Tuple[bool, List[str]]:\n        \"\"\"Validate workflow graph against project capabilities\"\"\"\n        errors = []\n        \n        try:\n            logger.info(\"🔍 UNIVERSAL: Starting workflow graph validation\")\n            \n            # Basic structure validation\n            structure_errors = WorkflowGraphValidator._validate_structure(graph_json)\n            errors.extend(structure_errors)\n            \n            if structure_errors:\n                return False, errors\n            \n            # Extract nodes and edges\n            nodes = graph_json.get('nodes', [])\n            edges = graph_json.get('edges', [])\n            \n            # Validate project capabilities\n            capability_errors = WorkflowGraphValidator._validate_capabilities(\n                nodes, project_capabilities\n            )\n            errors.extend(capability_errors)\n            \n            # Validate nodes\n            node_errors = WorkflowGraphValidator._validate_nodes(nodes)\n            errors.extend(node_errors)\n            \n            # Validate edges and connections\n            edge_errors = WorkflowGraphValidator._validate_edges(nodes, edges)\n            errors.extend(edge_errors)\n            \n            # Validate workflow flow\n            flow_errors = WorkflowGraphValidator._validate_workflow_flow(nodes, edges)\n            errors.extend(flow_errors)\n            \n            is_valid = len(errors) == 0\n            logger.info(f\"✅ UNIVERSAL: Graph validation {'passed' if is_valid else 'failed'} with {len(errors)} errors\")\n            \n            return is_valid, errors\n            \n        except Exception as e:\n            logger.error(f\"❌ UNIVERSAL: Graph validation exception: {e}\")\n            return False, [f\"Validation failed: {str(e)}\"]\n    \n    @staticmethod\n    def _validate_structure(graph_json: Dict) -> List[str]:\n        \"\"\"Validate basic graph structure\"\"\"\n        errors = []\n        \n        # Check for required top-level fields\n        if 'nodes' not in graph_json:\n            errors.append(\"Graph must contain 'nodes' field\")\n        elif not isinstance(graph_json['nodes'], list):\n            errors.append(\"'nodes' must be a list\")\n        \n        if 'edges' not in graph_json:\n            errors.append(\"Graph must contain 'edges' field\")\n        elif not isinstance(graph_json['edges'], list):\n            errors.append(\"'edges' must be a list\")\n        \n        return errors\n    \n    @staticmethod\n    def _validate_capabilities(nodes: List[Dict], project_capabilities: Dict) -> List[str]:\n        \"\"\"Validate against project capabilities\"\"\"\n        errors = []\n        \n        # Check agent count limit\n        max_agents = project_capabilities.get('max_agents_per_workflow', 10)\n        if len(nodes) > max_agents:\n            errors.append(f\"Maximum {max_agents} agents allowed, found {len(nodes)}\")\n        \n        # Check supported agent types\n        supported_types = project_capabilities.get('supported_agent_types', [])\n        \n        for node in nodes:\n            node_type = node.get('type')\n            if node_type not in supported_types:\n                errors.append(f\"Agent type '{node_type}' not supported by this project template\")\n        \n        # Check function tools support\n        function_tools = [n for n in nodes if n.get('type') == 'FunctionTool']\n        if function_tools and not project_capabilities.get('supports_function_tools', False):\n            errors.append(\"Function tools not supported by this project template\")\n        \n        return errors\n    \n    @staticmethod\n    def _validate_nodes(nodes: List[Dict]) -> List[str]:\n        \"\"\"Validate individual nodes\"\"\"\n        errors = []\n        node_counts = {}\n        \n        for i, node in enumerate(nodes):\n            # Check required fields\n            if 'id' not in node:\n                errors.append(f\"Node {i} missing required 'id' field\")\n            \n            if 'type' not in node:\n                errors.append(f\"Node {i} missing required 'type' field\")\n                continue\n            \n            node_type = node.get('type')\n            node_id = node.get('id', f'node_{i}')\n            \n            # Count node types\n            node_counts[node_type] = node_counts.get(node_type, 0) + 1\n            \n            # Validate against type specifications\n            if node_type in WorkflowGraphValidator.SUPPORTED_AGENT_TYPES:\n                type_spec = WorkflowGraphValidator.SUPPORTED_AGENT_TYPES[node_type]\n                \n                # Check required fields for this type\n                node_data = node.get('data', {})\n                for required_field in type_spec.get('required_fields', []):\n                    if required_field not in node_data or not node_data[required_field]:\n                        errors.append(f\"Node '{node_id}' ({node_type}) missing required field '{required_field}'\")\n        \n        # Check node type count limits\n        for node_type, count in node_counts.items():\n            if node_type in WorkflowGraphValidator.SUPPORTED_AGENT_TYPES:\n                max_count = WorkflowGraphValidator.SUPPORTED_AGENT_TYPES[node_type].get('max_count', float('inf'))\n                if count > max_count:\n                    errors.append(f\"Too many {node_type} nodes: {count} (max: {max_count})\")\n        \n        # Check for required StartNode\n        if 'StartNode' not in node_counts:\n            errors.append(\"Workflow must contain exactly one StartNode\")\n        elif node_counts['StartNode'] != 1:\n            errors.append(f\"Workflow must contain exactly one StartNode, found {node_counts['StartNode']}\")\n        \n        return errors\n    \n    @staticmethod\n    def _validate_edges(nodes: List[Dict], edges: List[Dict]) -> List[str]:\n        \"\"\"Validate edges and connections\"\"\"\n        errors = []\n        node_ids = {node.get('id') for node in nodes}\n        \n        for i, edge in enumerate(edges):\n            # Check required edge fields\n            if 'source' not in edge:\n                errors.append(f\"Edge {i} missing 'source' field\")\n                continue\n            if 'target' not in edge:\n                errors.append(f\"Edge {i} missing 'target' field\")\n                continue\n            \n            source_id = edge.get('source')\n            target_id = edge.get('target')\n            \n            # Check if source and target nodes exist\n            if source_id not in node_ids:\n                errors.append(f\"Edge {i} references non-existent source node '{source_id}'\")\n            if target_id not in node_ids:\n                errors.append(f\"Edge {i} references non-existent target node '{target_id}'\")\n            \n            # Prevent self-connections\n            if source_id == target_id:\n                errors.append(f\"Edge {i} creates self-connection on node '{source_id}'\")\n        \n        return errors\n    \n    @staticmethod\n    def _validate_workflow_flow(nodes: List[Dict], edges: List[Dict]) -> List[str]:\n        \"\"\"Validate workflow execution flow\"\"\"\n        errors = []\n        \n        # Build adjacency lists\n        outgoing = {node.get('id'): [] for node in nodes}\n        incoming = {node.get('id'): [] for node in nodes}\n        \n        for edge in edges:\n            source = edge.get('source')\n            target = edge.get('target')\n            if source and target:\n                outgoing[source].append(target)\n                incoming[target].append(source)\n        \n        # Find StartNode\n        start_nodes = [node for node in nodes if node.get('type') == 'StartNode']\n        if not start_nodes:\n            return errors  # Already handled in node validation\n        \n        start_node_id = start_nodes[0].get('id')\n        \n        # Check that StartNode has no incoming connections\n        if incoming.get(start_node_id):\n            errors.append(\"StartNode should not have incoming connections\")\n        \n        # Check that StartNode has outgoing connections\n        if not outgoing.get(start_node_id):\n            errors.append(\"StartNode must have at least one outgoing connection\")\n        \n        # Check for orphaned nodes (nodes with no connections)\n        for node in nodes:\n            node_id = node.get('id')\n            node_type = node.get('type')\n            \n            # Skip FunctionTool nodes as they don't participate in main flow\n            if node_type == 'FunctionTool':\n                continue\n            \n            has_connections = bool(incoming.get(node_id)) or bool(outgoing.get(node_id))\n            if not has_connections and node_type != 'StartNode':\n                errors.append(f\"Node '{node_id}' has no connections\")\n        \n        # Check for circular dependencies (basic cycle detection)\n        if WorkflowGraphValidator._has_cycles(nodes, edges):\n            errors.append(\"Workflow contains circular dependencies\")\n        \n        return errors\n    \n    @staticmethod\n    def _has_cycles(nodes: List[Dict], edges: List[Dict]) -> bool:\n        \"\"\"Detect cycles in the workflow graph\"\"\"\n        try:\n            # Build adjacency list\n            graph = {node.get('id'): [] for node in nodes}\n            for edge in edges:\n                source = edge.get('source')\n                target = edge.get('target')\n                if source and target:\n                    graph[source].append(target)\n            \n            # DFS cycle detection\n            visited = set()\n            rec_stack = set()\n            \n            def dfs(node_id):\n                if node_id in rec_stack:\n                    return True  # Cycle found\n                if node_id in visited:\n                    return False\n                \n                visited.add(node_id)\n                rec_stack.add(node_id)\n                \n                for neighbor in graph.get(node_id, []):\n                    if dfs(neighbor):\n                        return True\n                \n                rec_stack.remove(node_id)\n                return False\n            \n            # Check each node\n            for node_id in graph:\n                if node_id not in visited:\n                    if dfs(node_id):\n                        return True\n            \n            return False\n            \n        except Exception as e:\n            logger.error(f\"❌ UNIVERSAL: Error in cycle detection: {e}\")\n            return False  # Assume no cycles on error\n    \n    @staticmethod\n    def get_validation_summary(is_valid: bool, errors: List[str]) -> Dict[str, Any]:\n        \"\"\"Get formatted validation summary\"\"\"\n        return {\n            'valid': is_valid,\n            'error_count': len(errors),\n            'errors': errors,\n            'timestamp': logger.info.created if hasattr(logger.info, 'created') else None,\n            'validator_version': '1.0.0'\n        }\n\n\nclass WorkflowSecurityValidator:\n    \"\"\"Security validation for workflow execution\"\"\"\n    \n    @staticmethod\n    def validate_function_code(function_code: str) -> Tuple[bool, List[str]]:\n        \"\"\"Validate function code for security issues\"\"\"\n        errors = []\n        \n        # Check for dangerous imports and functions\n        dangerous_patterns = [\n            'import os',\n            'import subprocess',\n            'import sys',\n            '__import__',\n            'exec(',\n            'eval(',\n            'open(',\n            'file(',\n            'input(',\n            'raw_input('\n        ]\n        \n        for pattern in dangerous_patterns:\n            if pattern in function_code:\n                errors.append(f\"Potentially dangerous code pattern detected: {pattern}\")\n        \n        # Check code length\n        if len(function_code) > 10000:  # 10KB limit\n            errors.append(\"Function code exceeds maximum length (10KB)\")\n        \n        return len(errors) == 0, errors\n    \n    @staticmethod\n    def validate_execution_parameters(params: Dict) -> Tuple[bool, List[str]]:\n        \"\"\"Validate execution parameters for security\"\"\"\n        errors = []\n        \n        # Check parameter size\n        import json\n        try:\n            param_size = len(json.dumps(params))\n            if param_size > 100000:  # 100KB limit\n                errors.append(\"Execution parameters exceed size limit\")\n        except Exception:\n            errors.append(\"Invalid execution parameters format\")\n        \n        return len(errors) == 0, errors\n